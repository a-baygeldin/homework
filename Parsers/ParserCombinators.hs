module ParserCombinators where

--s - входные данные, a - дерево разбора
newtype Parser s a = P (s -> [(a, s)])

--Применяет к строке нужный парсер, возвращает список благоприятных исходов
apply :: Parser s a -> s -> [(a, s)]
apply (P p) = p 

--Возвращает парсер, который всегда валится
fail :: Parser s a
fail = P (\ _ -> [])

--Возвращает парсер, который всегда возвращает хвост с пустым результатом
any :: Parser [s] ()
any = P p where
  p []     = [((), [])]
  p (_:ss) = [((), ss)]

--Возвращает парсер, определяющий первый символ (или конструктор)
sym :: Eq s => s -> Parser [s] s
sym c = P p where p (x:xs) | x == c = [(x, xs)]
                  p _               = []

--Возвращает функцию, которая по любому значению возвращает парсер
lift :: Parser s a -> b -> Parser s a
lift p _ = p

--Возвращает парсер, который для любых данных выдает предопределенный результат
val :: a -> Parser s a
val a = P (\s -> [(a, s)])

--Складывает результаты двух парсеров для одних и тех же данных
infixl 2 |||
(|||) :: Parser s a -> Parser s a -> Parser s a
(P p) ||| (P q) = P (\ s -> p s ++ q s)

{- Возвращает парсер, который принимает строку, применяет к ней первый парсер,
потом проходит по возвращенному списку блгоприятных исходов и в каждом элементе
к первому значению в паре (т.е. к результату) применяет функцию, которая возвращает
новый парсер, после чего этот парсер она применяет к строке остаточной из пары 
и в итоге у нас получается список списков благоприятных исходов, который после 
этого конкатенируется. -}
infixl 3 ||>
(||>) :: Parser s a -> (a -> Parser s b) -> Parser s b
(P p) ||> q = P (\s -> concat [apply (q a) s | (a, s) <- p s])

{- Возвращает парсер, который парсит список того, что парсит парсер, 
который many принимает. Список может быть пустым. -}
many :: Parser s a -> Parser s [a]
many a = a ||> (\x -> many a ||> val . (x:)) ||| val []

{-
На примере парсера sym 'ц' и строчки "ццц" (т.е. many :: Parser [Char] a -> Parser [Char] [a]):
many (sym 'ц') применим к "ццц" =
((sym 'ц') ||> (\x -> many (sym 'ц') ||> val . (x:)) ||| val []) "ццц" =
concat [apply ((\x -> many (sym 'ц') ||> val . (x:)) a) s | (a, s) <- [('ц',"цц")]] ++ [([], "ццц")] =
concat [apply ((\x -> many (sym 'ц') ||> val . (x:)) 'ц') "цц"] ++ [([], "ццц")] =
concat [apply (many (sym 'ц') ||> val . ('ц':)) "цц"] ++ [([], "ццц")] =
concat [concat [apply (val . ('ц':) a) s | (a, s) <- many (sym 'ц') "цц"]] ++ [([], "ццц")] = *

many (sym 'ц') "цц" = 
((sym 'ц') ||> (\x -> many (sym 'ц') ||> val . (x:)) ||| val []) "цц" =
concat [apply ((\x -> many (sym 'ц') ||> val . (x:)) a) s | (a, s) <- [('ц',"ц")]] ++ [([], "цц")] =
concat [apply ((\x -> many (sym 'ц') ||> val . (x:)) 'ц') "ц"] ++ [([], "цц")] =
concat [apply (many (sym 'ц') ||> val . ('ц':)) "ц"] ++ [([], "цц")] =
concat [concat [apply (val . ('ц':) a) s | (a, s) <- many (sym 'ц') "ц"]] ++ [([], "цц")] = **

many (sym 'ц') "ц" =
((sym 'ц') ||> (\x -> many (sym 'ц') ||> val . (x:)) ||| val []) "ц" =
concat [apply ((\x -> many (sym 'ц') ||> val . (x:)) a) s | (a, s) <- [('ц', [])]] ++ [([], "ц")] =
concat [apply ((\x -> many (sym 'ц') ||> val . (x:)) 'ц') []] ++ [([], "ц")] =
concat [apply (many (sym 'ц') ||> val . ('ц':)) []] ++ [([], "ц")] =
concat [concat [apply (val . ('ц':) a) s | (a, s) <- many (sym 'ц') []]] ++ [([], "ц")] = ***

many (sym 'ц') []] =
((sym 'ц') ||> (\x -> many (sym 'ц') ||> val . (x:)) ||| val []) [] =
concat [apply ((\x -> many (sym 'ц') ||> val . (x:)) a) s | (a, s) <- []] ++ [([], [])] =
concat [] ++ [([], [])] = [([], [])]

*** = concat [concat [apply (val . ('ц':) a) s | (a, s) <- [([], [])]]] ++ [([], "ц")] =
concat [concat [apply (val . ['ц']) [] ]] ++ [([], "ц")] =
concat [concat [apply (\s -> [(['ц'], s)]) [] ]] ++ [([], "ц")] =
concat [concat [ [(['ц'], [])] ]] ++ [([], "ц")] =
[(['ц'], [])] ++ [([], "ц")] = [(['ц'], []), ([], "ц")]

** = concat [concat [apply (val . ('ц':) a) s | (a, s) <- [(['ц'], []), ([], "ц")]]] ++ [([], "цц")] =
concat [concat [apply (val . ('ц':) ['ц']) [], apply (val . ('ц':) []) "ц"]] ++ [([], "цц")] =
concat [concat [apply (s -> [(['ц','ц'], s]) [], apply (s -> [(['ц'], s)]) "ц"]] ++ [([], "цц")] =
concat [concat [ [(['ц','ц'], [])], [(['ц'], "ц")] ]] ++ [([], "цц")] =
[(['ц','ц'], []), (['ц'], "ц"), ([], "цц")]

* = concat [concat [apply (val . ('ц':) a) s | (a, s) <- [(['ц','ц'], []), (['ц'], "ц"), ([], "цц")]] ++ [([], "ццц")] =
concat [concat [apply (val . ('ц':) ['ц','ц']) [], apply (val . ('ц':) ['ц']) "ц", apply (val . ('ц':) []) "цц"] ++ [([], "ццц")] =
concat [concat [apply (s -> [(['ц','ц','ц'],s)] ) [], apply (s -> [(['ц','ц'],s)]) "ц", apply (s -> [(['ц'],s)]) "цц"] ++ [([], "ццц")] =
concat [concat [ [(['ц','ц','ц'],[])], [(['ц','ц'],"ц")], [(['ц'],"цц")] ] ++ [([], "ццц")] =
[(['ц','ц','ц'],[]), (['ц','ц'],"ц"), (['ц'],"цц"), ([], "ццц")]

Как можно видеть, это то же самое, что apply (many $ sym 'ц') "ццц"

Я постиг дзен.
-}

--many, который парсит не может парсить пустой список
some :: Parser s a -> Parser s [a]
some a = a ||> (\x -> many a ||> val . (x:))

--Возвращает парсер, котоырй возвращает список, где все результаты обрамлены в Maybe
opt :: Parser s a -> Parser s (Maybe a)
opt a = a ||> val . Just ||| val Nothing

{- Принимает результат парсера на вход и возвращает список всех результатов, 
где остаток не пустой. -}
eof :: Eq s => [(a, [s])] -> [a]
eof = map fst . filter ((==[]) . snd) 

